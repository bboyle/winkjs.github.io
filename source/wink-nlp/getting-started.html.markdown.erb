# Getting started

Let's start with "Hello, World!" in `wink-nlp`:

<pre class="prettyprint source lang-javascript"><code>var text = 'Hello   World!';
var doc = nlp.readDoc(text);
console.log(doc.out());
// -> Hello   World!</code></pre>

The `.readDoc()` method of nlp transforms the input text string into a wink-nlp document. It is the centerpiece of your code. The document provides a rich set of chainable API methods for easy navigation through it's sentences, entities and/or tokens. This simplifies information processing and extraction from a document.

The `out()` method always returns JavaScript’s built-in datatypes — most often arrays of Strings or objects. `doc.out()` is context dependent, for example, it produces a string in the code above but when applied on tokens, it outputs an array of strings:

<pre class="prettyprint source lang-javascript"><code>console.log( doc.tokens().out() );
// -> [ 'Hello', 'World', '!' ]</code></pre>

<div class="docs-tip docs-tip--green">
<code>wink-nlp</code> has a lossless tokenizer — notice how it has preserved and reproduced all the spaces between "Hello" and "World" in the first example.
</div>

## Boilerplate Code
We start by requiring the `wink-nlp` package and the language model. Then we instantiate `wink-nlp` using the language model:

<pre class="prettyprint source lang-javascript"><code>// Load wink-nlp package.
var winkNLP = require('wink-nlp');
// Load english language model — light version.
var model = require('wink-eng-lite-model');
// Instantiate wink-nlp.
var nlp = winkNLP(model);</code></pre>

The above is an absolute minimal boilerplate code. It works when the `out()` method is used without its optional arguments as seen in the "Hello, World!" example above.

<div class="docs-tip docs-tip--blue">
<strong>Convention:</strong> All code examples do not include the boilerplate code explicitly. In order to run any example, one must include the required boilerplate code on the top.
</div>

The `out()` method has two optional arguments — <code>its.<strong>propertyName</strong></code> and <code>as.<strong>reducedValue</strong></code>. Their use requires additional boilerplate code as outlined below:

<pre class="prettyprint source lang-javascript"><code>// Load "wink-nlp" package.
const winkNLP = require('wink-nlp');
// Load "its" helper to extract token properties
const its = require( 'wink-nlp/src/its.js' );
// Load "as" reducer helper to reduce a collection.
const as = require( 'wink-nlp/src/as.js' );
// Load english language model — light version.
const model = require('wink-eng-lite-model');
// Instantiate wink-nlp.
const nlp = winkNLP(model);</code></pre>

<div class="docs-tip docs-tip--green">
These optional arguments are extremely useful in information extraction:
<ol>
  <li>A token, entity, sentence or document has several contextual properties that are accessible via <code>its.<strong>propertyName</strong></code> such as <code>its.stopWordFlag</code>, <code>its.shape</code> and <code>its.vector</code>.</li>
  <li>The collection of tokens and entities can be reduced to <code>as.freqTable</code>, <code>as.bow</code> (bag of words), or <code>as.bigrams</code> etc. with <code>as.<strong>reducedValue</strong></code>.</li>
</ol>
</div>

<p>&nbsp;</p>

<div class="docs-tip docs-tip--blue">
  <strong>Convention:</strong> The <strong>bold</strong> part in a code fragment needs to be substituted with actual value according to the requirement. For example as observed above, the <code><strong>propertyName</strong></code> in <code>its.<strong>propertyName</strong></code> can have a value such as <code>stopWordFlag</code>, <code>shape</code> or <code>vector</code>.
</div>

Let's explore the `wink-nlp` document in the [next section](document.html).

<div class="l-horizontal">
  <div class="empty-nav-link">&nbsp;</div>

  <a href="document.html" class="bottom-nav-link next-nav-link">
    <span class="bottom-nav-link__title">Next</span>
    Document
  </a>
</div>
