---
title: Custom Entities
---

# Custom Entities

Custom Entities have two methods — `learnCustomEntities()` to define application specific custom entities, and `customEntities()` to access the custom entities detected during `.readDoc()` execution.

<div class="docs-tip docs-tip--green">
  The <code>customEntities()</code> method offers the same API methods that <code>entities()</code> does.
</div>

With `learnCustomEntities()` you can define your own custom entities in terms of patterns. These patterns consist of either a single token, a phrase having multiple words (i.e. multiple tokens), their entity type, part-of-speech, or any combination of these. In a pattern, a single token or part-of-speech matches with a single **token** whereas an entity may match with **one or more tokens**.

<div class="docs-tip">
  The <code>learnCustomEntities()</code> method  must be called before <code>readDoc()</code>.
</div>

The following example illustrates how a single token and a phrase is matched:

<pre class="prettyprint source lang-javascript"><code>const text = 'Manchester United is a football club based in Manchester.';
const patterns = [
  { name: 'club', patterns: [ 'manchester united' ] },
  { name: 'city', patterns: [ 'manchester' ] }
];
nlp.learnCustomEntities(patterns);
const doc = nlp.readDoc(text);
doc.customEntities().out(its.detail);
// -> [ { value: 'Manchester United', type: 'club' },
//      { value: 'Manchester', type: 'city' } ]</code></pre>

<div class="docs-tip">
  It performs a <em>greedy</em> match and in case of multiple matches, the longest one is given preference.
</div>

Here is another example to extract adjective-noun pairs from a text:

<pre class="prettyprint source lang-javascript"><code>const text = 'The quick brown fox jumps over the lazy dog.';
const patterns = [
  { name: 'adjectiveNounPair', patterns: [ 'ADJ NOUN' ] }
];
nlp.learnCustomEntities(patterns);
const doc = nlp.readDoc(text);
doc.customEntities().out();
// -> [ 'brown fox', 'lazy dog' ]</code></pre>

<div class="docs-tip">
  Note the part-of-speech tags in the patterns follow the <a href="https://universaldependencies.org/u/pos/all.html">Universal POS tags standard</a> and therefore are always in UPPERCASE. Similarly, entity names are also in UPPERCASE. Some examples are DATE, DURATION, or EMAIL. For a complete list of entities and pos tags refer to the documentation of the desired language model.
</div>

## Shorthand patterns

Let us say we wish to extract noun phrases from the following text:

<pre class="prettyprint source lang-javascript"><code>const text = `Each time we gather to inaugurate a President we bear witness to the enduring strength of our Constitution.`;</code></pre>

To keep things simple, we assume that a noun phrase could be simply composed as:

<pre class="prettyprint source lang-javascript"><code>const patterns = [
  {
    name: 'nounPhrase',
    patterns: [
      'NOUN',
      'PROPN',
      'DET NOUN',
      'DET PROPN',
      'ADJ NOUN',
      'ADJ PROPN',
      'DET ADJ NOUN',
      'DET ADJ PROPN'
    ]
  }
];</code></pre>

The above list could be transformed into the following shorthand pattern:

<pre class="prettyprint source lang-javascript"><code>const patterns = [
  {
    name: 'nounPhrase',
    patterns: [ '[|DET] [|ADJ] [NOUN|PROPN]' ]
  }
];</code></pre>

In shorthand patterns:

1. Options are listed between opening and closing square brackets
2. Each option is separated by a vertical pipe character as in `[NOUN|PROPN]``
3. There can not be any space character within the square brackets
4. An option may be empty as in the case of the first two sets of options — `[|DET]`  and `[|ADJ]`
5. Between successive options lists, there should be one or more spaces — `[|DET] [|ADJ] [NOUN|PROPN]`
6. All options are automatically generated by finding all possible combinations — here there are 2-options in every list resulting in 2x2x2 = 8 combinations as shown in the previous pattern.

Given below is the complete code along with the output:

<pre class="prettyprint source lang-javascript"><code>const text = `Each time we gather to inaugurate
a President we bear witness to the enduring strength
of our Constitution.`;
const patterns = [
  {
    name: 'nounPhrase',
    patterns: [ '[|DET] [|ADJ] [NOUN|PROPN]' ]
  }
];
nlp.learnCustomEntities(patterns);
const doc = nlp.readDoc(text);
doc.customEntities().out();
// -> [ 'Each time',
//      'a President',
//      'witness',
//      'the enduring strength',
//      'Constitution' ]</code></pre>

## Escaping

In order to match literally with entity or part-of-speech types such as DATE (entity) or NOUN (part-of-speech), we must prefix such literals with a caret sign. For example, the pattern `'DATE'` will match with the sequence of tokens representing dates (e.g. August 29, 1961) but the pattern `'^DATE'` will match with the token having a value ‘DATE’. Think of the caret sign as JavaScript back-slash. Similarly in order to match literally with a caret sign, you need to escape it too — `'^^'`  will match literally with the token having a value ‘^’.

## Match sequence

During detection phase, match is performed in the following sequence:

1. Entity types are matched first;
2. In case of no match at setp #1, token value match is attempted;
3. If no match is found at step #2, then at last the token’s part-of-speech is matched.

<div class="docs-tip docs-tip--green">
  Custom Entities can be used as a fast pattern search in a corpus.
</div>

<div class="l-horizontal">
  <a href="visualizing-markup.html" class="bottom-nav-link">
    <span class="bottom-nav-link__title">Previous</span>
    Visualizing using markup
  </a>
  <div class="empty-nav-link">&nbsp;</div>
</div>

<div class="l-horizontal">
  <div class="empty-nav-link">&nbsp;</div>

  <a href="wink-nlp-in-browsers.html" class="bottom-nav-link next-nav-link">
    <span class="bottom-nav-link__title">Next</span>
    WinkNLP in browsers
  </a>
</div>
